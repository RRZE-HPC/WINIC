

TODO
    something is causing free(): invalid (genoa)
    some instructions e.g. adc (ADC16ri8) on zen4 get a TP penalty when unrolling the loop without breaking the dependency on the flags. try to avoid
    some instructions always work on e.g. rax -> currently latency not TP is measured (XOR16i16)
    replace generic errors
    init registers (e.g. avoid avx-sse transition penalty)
    latency benchmarks
    test lukewarm (sve)
    test riscv
        add templates for riscv plan release packaging configure llvm installation to include clang but be as fast as possible
    instructions with weird values
        ADD_FST0r 
        XOR8rr_NOREX
        ADC16ri8 - adcs are broken bc of flags dependency
        CLC
        CMC
        COM_FIPr
        DIV16r
        IMUL16r
        LAHF
        MUL32r
        MUL8r

    done:
    instructions with weird values
        -COM_Fpr32 - was an undetected pseudo instruction
    -remove rounding in loop overhead calculation
    -reuse readonly regs for TP bench, in some cases there are too few instructions (MMX_PMULLWrr)
    -move to clang for assembling to avoid gcc dependency
    -    ->check if equal number of successful measurements
    -    ->check if syntaxVariants are still correct
    -test if variant with clang assembler works on x86
    -MCInstrPrinter segfaults when instruction is wrong (or is Prefix)
    -check filtering memory instructions
    -implement loop instruction interference detection
    -compile and run benchmarks from inside program
    -save callee saved registers

State
    Conditional moves measure garbage CMOVNE_F
    ND and EVEX encoded variants cause ERROR_ASSEMBLY (this is ok, normal variants get measured)
    where to verify aarch data -osaca
    -how to set/read clock frequency on arm
        warmup: 2.2GHz
        grace admin
    likwid broken on arm likwid/grace

Questions:
    always same immediate correct?
    TP only to determine number of execution units?



helpful
    TRI->getRegAsmName(MCRegister)
    llvm::X86::getFeaturesForCPU(StringRef CPU, SmallVectorImpl<StringRef> &Features)
    desc.hasImplicitUseOfPhysReg(MCRegister::from(X86::EFLAGS))
    MCII->getName(opcode).data()


cd bachelor/llvm-project/build/own_tools/llvm-bench
salloc --nodes=1 -w icx36 --time=02:00:00 -C hwperf
srun --cpu-freq=2400000-2400000:performance cat /proc/cpuinfo | grep MHz
srun --cpu-freq=2400000-2400000:performance ./llvm_instr_gen -f 2.4 -i ADC16ri8 
srun --cpu-freq=2400000-2400000:performance ./llvm_instr_gen -f 2.4 > genoa.log
srun --cpu-freq=2400000-2400000:performance ./quick 2.4
./llvm_instr_gen -f 2.2 > warmup.log

srun --cpu-freq=2400000-2400000:performance ./llvm_instr_gen -f 2.4 -i MMX_PMULLWrr 


Testfront
    salloc --nodes=1 -w icx36 --time=02:00:00
    salloc --nodes=1 -w genoa1 --time=02:00:00

    module load cmake gcc python
    mkdir -p llvm-project/build && cd llvm-project/build
    cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_LLVM_DYLIB=ON -DLLVM_LINK_LLVM_DYLIB=ON ../llvm
    cmake --build . -- -j 32
    mkdir own_tools && cd own_tools
    git clone https://github.com/TobiasRTR/llvm-bench.git

    #build with clangd or all
    cmake -DCMAKE_BUILD_TYPE=Release ../llvm -DLLVM_BUILD_LLVM_DYLIB=ON -DLLVM_LINK_LLVM_DYLIB=ON  -DLLVM_ENABLE_PROJECTS="clang;clang-tools-extra"
    cmake --build . --target clangd/all -- -j 64

x86:
CLD
BSWAP64r r64 
ADD64rr r64 r64
ADD64ri32 r64 i32
ADC16i16 i16 always works on ax, how to measure TP
VFMADD132PDYr ymm ymm ymm


AArch64:
ABSWr
FMADDDrrr

Später: Portbelegung

Sei A Instruktion mit Lat_A, TPr_A und B Instruktion mit Lat_B, TPr_B
A und B nutzen nur einen Port während ihrer Ausführung TODO was wenn nicht
Sei TPr_B < Lat_A
Sei T die Anzahl von Taktzyklen, die eine Latenzkette von A, beliebiger aber fester Länge braucht
Sei TI_n die Anzahl von Taktzyklen, die die Kette braucht wenn n unabhängige Bs nach jedem A eingefügt werden
    Wenn A und B unterschiedliche Ports nutzen bleibt T bei n *  <= Lat_A / TPr_B gleich
    Wenn A und B die selben Ports nutzen steigt T bereits vorher

zusätzlich: falls überlappung nicht erkannt weil nutzung des uberlappenden ports sehr gering,
finde trotzdem indirekt durch instruktion die den Port hauptsächlich verwendet


MUL8r -> latenz wird gemessen weil immer auf al
    Lösug: interleave mit mov rax, 42
    -> TP = 1.0
    Frage: muss man noch die 0.25 vom mov abziehen? -> 0.75
    oder nicht -> 1.0
        Lösung: interleave mit MOV bricht dependency
        miss MUL:MOV 1:1: und 1:2
        wenn TP_MUL gleich bleibt muss mov auf anderen Ports laufen
        wenn TP_MUL sinkt sind es die gleichen Ports
        Bedingung: TP_MOV muss kleiner gleich 1/2 TP_MUL sein

Sei TP_MOV <= TP_MUL /2
Sei T_11 die Zeit von MUL und MOV 1:1 interleaved
Sei T_12 der Zeit von MUL und MOV 1:2 interleaved
    Wenn MUL und MOV gleiche Ports nutzen:
        Die zusätzlichen MOVs müssen die Ausführungszeit verlängern
        -> T_12 > T_11
    Wenn MUL und MOV Verschiedene Ports nutzen:
        TP_MOV <= TP_MUL / 2 -> T_MOV <= T_MUL / 2 
        2 * T_MOV <= 2 * (T_MUL / 2 )
        -> 2 * T_MOV <= T_MUL
        MUL und MOV auf verschiedenen Ports
        -> MOVs verschwinden hinter MULs und erhöhen die Laufzeit nicht



ADC kein TP
ADD TP=0.25 bricht adc dependency
wenn beide auf verschiedenen ports laufen gibt es eine ratio bei der beide tps kleiner gleich dem minimalen einzel TP sind
wenn 1:1 run: keine dependencys
    wenn gleiche Ports: TP_comb = TPadc + TPadd
    wenn verschiedene Ports: 


if flags dependency:
    interleave with dependency breaking instruction bi 1:1 and 9:1
    if TP_combined > TP_bi:
        TP = TP_combined - TP_mov (same ports)
    else (TP_combined == TP_bi)
        TP <= TP_combined (no final answer since either equal to TP_bi or limited by TP_bi)
    

if instruction only one register (add eax, imm)
    interleave with mov eax, imm with TP_mov
    if TP_combined > TP_mov
        if same ports
            TP = TP_combined - TP_mov
        else different ports (how to detect???)
            TP = TP_combined
    else 
        TP = 

alternative
    measure TP_add 
    measure TP_add with add_eax every 1/TP_add instructions
    if results are same -> TP is same
    for uops case: TP_add = 0.25 TP_add_eax = 0.33
        TP_combined = 3/4*0.25 + 1/4*0.33 = 0.27
        but this is not the case

    code:
    add	eax, 42
	add	r13d, 42
	add	r14d, 42
	add	r15d, 42
    -> TP 0.25


    #TP 0.254 unrolled
	adc	ax, 42
	adc	cx, 42
	adc	dx, 42
	adc	si, 42
	adc	bx, 42
	adc	r9w, 42
	adc	r10w, 42
	adc	r11w, 42
	adc	r14w, 42
	adc	r15w, 42
	adc	r12w, 42
	adc	r13w, 42
    clc

    #TP 0.336 unrolled
	adc	r14w, 1
    xor eax, eax
	adc	cx, 1
    xor eax, eax
	adc	dx, 1
    xor eax, eax
	adc	si, 1
    xor eax, eax
	adc	bx, 1
    xor eax, eax
	adc	r9w, 1
    xor eax, eax
	adc	r10w, 1
    xor eax, eax
	adc	r11w, 1
    xor eax, eax

    #TP 0.253 unrolled
    adc cx, 1
    add	r13w, 1
	adc	bx, 1
    add	r14w, 1
	adc	r9w, 1
    add	r15w, 1
	adc	r10w, 1
    add cx, 1
	adc	r11w, 1
    add	bx, 1
    adc	r12w, 1
    add	r9w, 1
    adc	r13w, 1
    add	r10w, 1
    adc	r14w, 1
    add	r11w, 1
    adc	r15w, 1
    add	r12w, 1

    #TP 0.377 unrolled
    adox	ecx, ebx
	adox	edx, ebx
	adox	r9d, ebx
	adox	r10d, ebx
	adox	r11d, ebx
	adox	r12d, ebx
	adox	r13d, ebx
	adox	r14d, ebx
    xor eax, eax

    #TP 0.258 unrolled
    adox	ecx, ebx
    add	r12d, 1
	adox	edx, ebx
    add	r13d, 1
	adox	r9d, ebx
    add	r14d, 1
	adox	r10d, ebx
    add ecx, 1
	adox	r11d, ebx
    add	edx, 1
	adox	r12d, ebx
    add	r9d, 1
	adox	r13d, ebx
    add	r10d, 1
	adox	r14d, ebx
    add	r11d, 1

    
    #TP 0.336 unrolled
    adox	ecx, ebx
    xor eax, eax
	adox	edx, ebx
    xor eax, eax
	adox	r9d, ebx
    xor eax, eax
	adox	r10d, ebx
    xor eax, eax
	adox	r11d, ebx
    xor eax, eax
	adox	r12d, ebx
    xor eax, eax
	adox	r13d, ebx
    xor eax, eax
	adox	r14d, ebx
    xor eax, eax




#TODO
write meta script to setup llvm, insert and compile llvm-bench
look at shallow cloing llvm for this
compile llvm with Debug for development

important files:
RegAllocBase.cpp ?
X86RegisterInfo.td
X86TargetMachine.h

MCContext.h
MCSubtargetInfo.h
MCInst.h
MCInstDesc.h
MCRegister.h
MCRegisterInfo.h
TargetMachine.h
TargetSubtargetInfo.h
TargetRegistry.h
MachineRegisterInfo.h
MachineFunction.h
MachineOperand.h
MachineInstr.h


APX extension adds r16-r31
Registers are just in a certain order, so as more extensions are supported the index of the last supported register increases
see TRI->getNumSupportedRegs(*MF)

What if instructions interfere with instructions used by loop (cmp, jl, inc) (cmp and jl can be fused)
    run twice with ninst and 2*ninst for runimes a and b
    use formula x = ninst * (b - 2 * a) / (a - b)
    to get x interfering instructions and correct TP calculation 


SSE names
    fma, order of operands, packed, double 
    VFMADD132PD xmm1 xmm2 xmm3
        xmm1 = xmm1*xmm3 + xmm2
    VFMADD213PD xmm1 xmm2 xmm3
        xmm1 = xmm2*xmm1 + xmm3
    VFMADD231PD xmm1 xmm2 xmm3
        xmm1 = xmm2*xmm3 + xmm1

    in llvm:
    VFMADD132PDYm
    VFMADD132PD VR256 VR256 f256mem

    VFMADD132PDYr
    VFMADD132PD VR256 VR256 VR256

    VFMADD132PDm
    VFMADD132PD VR128 VR128 f128mem

    LLVM: 
    fma, order, packed, double, 256Bit(Y), 3rd operand register
    VFMADD132PDYr


    VFMADD132PDZ128m:
    fma, order, packed, 512Bit, ?, memory
    VR128X

    General (VFMADD132PDZ256mbkz)
    VFMADD {132|213|231}   {P|S}          {D|S}             { |Y|Z}       {128|256| }   {m|r}             {b| }       {k|kz| }
            operand order   packed|scalar  douvble|single       |AVX512    xmm|ymm|zmm   mem|reg (3rd op)  broadcast   destination_mask|zero_where_mask_0

    128|256 only available when Z (avx512)
    memory variant ignored in osaca?
    broadcast: uses a 64bit memory operand and boradcasts the value to the avx register before the fmadd


AArch64 names
    ADDSWrs 
    ADDS {W,X} r {x|i|s}
    add {32bit,64bit} register? {extended, immediate shifted}


clangd path is in workspace


	adox	eax, ecx
    test r12, r12
	adox	edx, esi
    test r12, r12
	adox	ebx, r9d
    test r12, r12
	adox	r10d, r11d
    test r12, r12
	adox	r14d, r15d
    test r12, r12
	adox	eax, ecx
    test r12, r12
	adox	edx, esi
    test r12, r12
	adox	ebx, r9d
    test r12, r12
	adox	r10d, r11d
    test r12, r12
	adox	r14d, r15d
    test r12, r12