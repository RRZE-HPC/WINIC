
TODO
    before publish
        loop_tpUnroll2 asm label improve naming convention
        replace tp at end of notes
        make debug print function parameters
        implement setup
        implement output system
        run iwyu
    lat: dont report 0 if lower boundry
    investigate vcvtph2ps ymm xmm on cascadelake, why match if no uops data
    ADD_FrST0 takes 7 cycles on zen4 and 400+ on cascadelake. think about what to do.
    cleanup init code generation in genLatBenchmark4
    rename 
        tpInnerLoop -> tploop
    add init registers to tp benchmark
    fix always munmap
    main does not keep order of mixed input opcode and instruction names
    
    proof of concept riscv
    improve comparison to uops
    plan release packaging
    issues to add:
        improve register saving logic (use llvm)
        calculateCycles move explanation into issue
        tp match immediate to immediate size
    latency
        is helper selection deterministic?
        round 0.999 to 1
        find best instead of first helper (with minimal sideeffects)
        RCR16rCL values missing and incorrect
        why does CDQ use helper?
        IMUL16r no prio helper mov?
        BTC16ri8 has r->r 1 and r->flags 2 but i get opposite?
        there may be implicit dependencys which hide the latency we want to measure. -> add a check for this
        add measurements with same regs for different operands to check if zero
        optimize canMeasure to do less loop iterations
        add check for helpers not to be variants of same instruction
    Throughput
        
        if bounds 2.76612 - 3.01737 dont report lower
        make single measurement args order independent
        
    /dev/shm/temp.s:114:2: error: instruction requires: Not 64-bit mode mov cr0, eax investigate
    add frequency check
    test lukewarm
        test Latency
        test sve
    test riscv
        add templates for riscv
    
    instructions with weird TP values
        KMOVWrk weird when unroll 1-2 loops, correct when 2-4 loops
        ADD_FST0r 
        XOR8rr_NOREX
        ADC16ri8 - adcs are broken bc of flags dependency
        CLC
        CMC
        COM_FIPr
        DIV16r
        IMUL16r
        LAHF
        MUL32r
    instructions with weird LAT values
        VRSQRTSSr -0.5 in bench but correct 4.0 when single measurement?
        VUNPCKLPDZrr - 1.114 but should be 1.0 -> probably transition penalty? not solved via init function
        HADDPDrr - 4.45 but should be 4.0 -> same reason as VUNPCKLPDZrr?
        CVTSI2SDrr
        CDQ
        CMP16ri
        SUB32rr broken in Lat4.log check if fixed now 
    instructions with better values than uops
        VANDPDZ128rrk TP


done:
    instructions with weird values
        -COM_Fpr32 - was an undetected pseudo instruction
    -add runtime to output
    -properly organize and create headers
    -something is causing free(): invalid (genoa, TP, around opcode 4692) it was STD which corrupts the heap
    -some instructions e.g. adc (ADC16ri8) on zen4 get a TP penalty when unrolling the loop without breaking the dependency on the flags. try to avoid
    -restructure project
    -write global toString function
    -put normal and unrolled benchmarks in same assemby file
    -change latency bench to also use instructions which access superregisters or subregisters as helper -dont do that, could enable optimizations
    -/usr/bin/ld: warning: /tmp/temp-c3f742.o: missing .note.GNU-stack section implies executable stack
    -init registers (e.g. avoid avx-sse transition penalty)
    -latency genInst not optimal, VANDNPSZ128rr uses same reg for both reads allowing for optimization to happen
    -dont spawn subprocess for every instruction
    -rename ERRORS
    -Helper instructions have to be handled outside of the subprocess otherwise they dont see each other
    -dont use subprocess
    -remove rounding in loop overhead calculation
    -reuse readonly regs for TP bench, in some cases there are too few instructions (MMX_PMULLWrr)
    -move to clang for assembling to avoid gcc dependency
    -    ->check if equal number of successful measurements
    -    ->check if syntaxVariants are still correct
    -test if variant with clang assembler works on x86
    -MCInstrPrinter segfaults when instruction is wrong (or is Prefix)
    -check filtering memory instructions
    -implement loop instruction interference detection
    -compile and run benchmarks from inside program
    -save callee saved registers

State
    Conditional moves measure garbage CMOVNE_F
    ND and EVEX encoded variants cause ERROR_ASSEMBLY (this is ok, normal variants get measured)
    where to verify aarch data -osaca
    -how to set/read clock frequency on arm
        warmup: 2.2GHz
        grace admin
    likwid broken on arm likwid/grace use -> grace verion

Questions:


riscv testen
verschiedene immediates testen -> warning

llvm git commit hash developed against: 8616c873350a2fd91c0c8028065daf8026ce515f


helpful
    TRI->getRegAsmName(MCRegister)
    llvm::X86::getFeaturesForCPU(StringRef CPU, SmallVectorImpl<StringRef> &Features)
    desc.hasImplicitUseOfPhysReg(MCRegister::from(X86::EFLAGS))
    MCII->getName(opcode).data()

use 2.4Ghz on genoa1 and 2.3Ghz on genoa2

cd bachelor/llvm-project/build/own_tools/llvm-bench
salloc --nodes=1 -w icx36 --time=02:00:00 -C hwperf
srun --nodes=1 -w genoa1 --time=04:00:00 --cpu-freq=2400000-2400000:performance ./LLVMBench LAT -f 2.4 > genoaLat.log
srun --nodes=1 -w genoa3 --time=04:00:00 --cpu-freq=1500000-1500000:performance ./LLVMBench TP -f 1.5 > genoa.log
srun --nodes=1 -w genoa2 --time=04:00:00 --cpu-freq=1500000-1500000:performance ./LLVMBench LAT -f 1.5 > genoaLAT.log
# fritz sapphire rapid 
srun --cpu-freq=2000000-2000000:performance ./LLVMBench TP -f 2.0 > spr.log
# casclakesp2
srun --cpu-freq=1000000-1000000:performance ./LLVMBench TP -f 1.0 -i VANDPDZ128rrk
# ivyep1
srun --cpu-freq=1200000-1200000:performance ./LLVMBench TP -f 1.2 -i ADC16ri8
# genoa
ml likwid/5.2.2 && likwid-setFrequencies -t 0 && likwid-setFrequencies -f 1.5
ml likwid/5.2.2 && likwid-setFrequencies -t 1 && likwid-setFrequencies -f 3.25

#get freq
srun --cpu-freq=2000000-2000000:performance cat /proc/cpuinfo | grep MHz
srun --nodes=1  --time=04:00:00 --cpu-freq=1500000-1500000:performance ./LLVMBench1 LAT -f 1.5 > genoaLAT.log
./LLVMBench LAT -f 2.4 > genoaLAT.log
./LLVMBench TP -f 2.4 > genoa.log
./LLVMBench TP -f 2.4 --minOpcode=4699 --maxOpcode=4700 > genoa.log
./LLVMBench TP -f 2.4 -o 4693
./LLVMBench LAT -f 2.4 -n 1000 > genoaLatDebug.log
./LLVMBench LAT -f 2.4 -i ADC16ri8
./LLVMBench TP -f 2.4 -i ADC16ri8
./quick 2.4
cat /proc/cpuinfo | grep MHz
module load likwid/5.2.2
likwid-setFrequencies -p #print
likwid-setFrequencies -l #list freq
likwid-setFrequencies -f 1.5 #set
ml likwid/5.2.2 && likwid-setFrequencies -t 0 && likwid-setFrequencies -f 1.5
ml likwid/5.2.2 && likwid-setFrequencies -t 0 && likwid-setFrequencies -f 1.2
likwid-setFrequencies -reset


/home/hpc/ihpc/ihpc149h/bachelor/llvm-project/build_all/bin/clang -x assembler-with-cpp -shared debug.s

benchmark
    perf record -g ./LLVMBench LAT -f 2.4 -n 1000
    perf record -g --call-graph dwarf ./LLVMBench LAT -f 2.4 --minOpcode=1000
    perf script | ./FlameGraph/stackcollapse-perf.pl > out.folded
    ./FlameGraph/flamegraph.pl out.folded > flamegraph_debugClang.svg

Testfront setup
    salloc --nodes=1 -w icx36 --time=02:00:00
    salloc --nodes=1 -w genoa1 --time=02:00:00

    module load cmake gcc python likwid
        
        mkdir -p llvm-project/build && cd llvm-project/build
        cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_LLVM_DYLIB=ON -DLLVM_LINK_LLVM_DYLIB=ON ../llvm
        cmake --build . -- -j 32
        mkdir own_tools && cd own_tools
        git clone https://github.com/TobiasRTR/llvm-bench.git

    #build with clangd or all
        cmake -DCMAKE_BUILD_TYPE=Release ../llvm -DLLVM_BUILD_LLVM_DYLIB=ON -DLLVM_LINK_LLVM_DYLIB=ON -DLLVM_ENABLE_PROJECTS="clang;clang-tools-extra"
        cmake --build . --target clangd/all -- -j 64


    #build_x86_2 (this will be 150GB)
        cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo ../llvm -DLLVM_BUILD_LLVM_DYLIB=ON -DLLVM_LINK_LLVM_DYLIB=ON -DLLVM_ENABLE_PROJECTS="clang;clang-tools-extra" -DLLVM_INSTALL_TOOLCHAIN_ONLY=ON
        cmake --build . --target install -- -j 64

    # iwyu
        git clone https://github.com/llvm/llvm-project.git
        git clone https://github.com/include-what-you-use/include-what-you-use.git
        cd llvm-project
        git checkout release/20.x
        cd ../include-what-you-use
        git checkout release/clang_20
        cd ..
        mkdir build && cd build
        cmake -DCMAKE_BUILD_TYPE=Release ../llvm -DLLVM_ENABLE_PROJECTS=clang -DLLVM_EXTERNAL_PROJECTS=iwyu -DLLVM_EXTERNAL_IWYU_SOURCE_DIR=../../include-what-you-use 
        
        alias iwyu="/home/woody/ihpc/ihpc149h/bachelor/llvm-project/build/bin/include-what-you-use"

        #haswell for valgrind
        cd $WORK
        cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_LLVM_DYLIB=ON -DLLVM_LINK_LLVM_DYLIB=ON -DCMAKE_CXX_FLAGS="-march=haswell" -DLLVM_TARGETS_TO_BUILD="X86;AArch64" ../llvm
        objdump -d ./LLVMBench | grep -iE 'vpdpbusd|vpmadd52|vpopcntd|zmm'

    likwid-pin -c 0-191 cmake --build . -- -j 192

    # create compile_commands.json
    ~/bachelor/llvm-project/build_x86/bin/intercept-build make

    #valgrind. doesnt work because unknown instruction likely avx512 -> recompiled llvm for haswell but didnt work
    module use /home/woody/ihpc/ihpc149h/USER-SPACK/share/spack/modules/linux-ubuntu24.04-x86_64_v4/
    ml valgrind

    LD_HWCAP_MASK=0x0 valgrind --sim-hints=lax-ioctls --vex-iropt-level=0 ./LLVMBench TP -f 2.4 --minOpcode=4690 --maxOpcode=4700
    likwid-pin -c 0-191 cmake --build . -- -j 192

#old 
cmake -DCMAKE_BUILD_TYPE=Release \
  -DLLVM_SOURCE_DIR=../../../llvm \
  -DLLVM_BINARY_DIR=../../../build_x86 \
  -DLLVM_DIR=.../../../build_x86/lib/ cmake/llvm \
  -DClang_DIR=../../../build_x86/lib/cmake/clang \
  -DCLANG_PATH=../../../build_x86/bin/clang ..

debugging
    ./LLVMBench TP -f 2.4 --minOpcode=4690 --maxOpcode=4700 is crashing
    #this doesnt show ouptut???
    ASAN_SYMBOLIZER_PATH=//home/hpc/ihpc/ihpc149h/bachelor/llvm-project/build_x86/bin/llvm-symbolizer ./LLVMBench TP -f 2.4 --minOpcode=4690 --maxOpcode=4700
    
Dont do this again:
    ALWAYS wrap measurements in a subprocess.
    even if signals are caught reliably there are too many side effects we cannot predict:
    STD reverses order of string operations and causes heap corruption

Parial write penalty on zen4:
    e.g. mov al 7 needs 2 uops because no wiring to write only 8 bits

    

total runtime: 34.612634 (s) lat n= 1000


x86:
CLD
BSWAP64r r64 
ADD64rr r64 r64
ADD64ri32 r64 i32
ADC16i16 i16 always works on ax, how to measure TP
VFMADD132PDYr ymm ymm ymm


AArch64:
ABSWr
FMADDDrrr

Constraints for immediates x86 TODO test:
    MMX_PALIGNRrri imm < 12 or else lat 2 instead of 0.5 bc result 0


Später: Portbelegung

Sei A Instruktion mit Lat_A, TPr_A und B Instruktion mit Lat_B, TPr_B
A und B nutzen nur einen Port während ihrer Ausführung TODO was wenn nicht
Sei TPr_B < Lat_A
Sei T die Anzahl von Taktzyklen, die eine Latenzkette von A, beliebiger aber fester Länge braucht
Sei TI_n die Anzahl von Taktzyklen, die die Kette braucht wenn n unabhängige Bs nach jedem A eingefügt werden
    Wenn A und B unterschiedliche Ports nutzen bleibt T bei n *  <= Lat_A / TPr_B gleich
    Wenn A und B die selben Ports nutzen steigt T bereits vorher

zusätzlich: falls überlappung nicht erkannt weil nutzung des uberlappenden ports sehr gering,
finde trotzdem indirekt durch instruktion die den Port hauptsächlich verwendet


MUL8r -> latenz wird gemessen weil immer auf al
    Lösug: interleave mit mov rax, 42
    -> TP = 1.0
    Frage: muss man noch die 0.25 vom mov abziehen? -> 0.75
    oder nicht -> 1.0
        Lösung: interleave mit MOV bricht dependency
        miss MUL:MOV 1:1: und 1:2
        wenn TP_MUL gleich bleibt muss mov auf anderen Ports laufen
        wenn TP_MUL sinkt sind es die gleichen Ports
        Bedingung: TP_MOV muss kleiner gleich 1/2 TP_MUL sein

Sei TP_MOV <= TP_MUL /2
Sei T_11 die Zeit von MUL und MOV 1:1 interleaved
Sei T_12 der Zeit von MUL und MOV 1:2 interleaved
    Wenn MUL und MOV gleiche Ports nutzen:
        Die zusätzlichen MOVs müssen die Ausführungszeit verlängern
        -> T_12 > T_11
    Wenn MUL und MOV Verschiedene Ports nutzen:
        TP_MOV <= TP_MUL / 2 -> T_MOV <= T_MUL / 2 
        2 * T_MOV <= 2 * (T_MUL / 2 )
        -> 2 * T_MOV <= T_MUL
        MUL und MOV auf verschiedenen Ports
        -> MOVs verschwinden hinter MULs und erhöhen die Laufzeit nicht



Paper
    Latency on adc	ax, 42 not possible, use auto detected interleave instruction 
    which reads adc and writes flags, subtract TP of interleave instruction (e.g. cmp)

    ADC kein TP
    ADD TP=0.25 bricht adc dependency
    wenn beide auf verschiedenen ports laufen gibt es eine ratio bei der beide tps kleiner gleich dem minimalen einzel TP sind
    wenn 1:1 run: keine dependencys
        wenn gleiche Ports: TP_comb = TPadc + TPadd
        wenn verschiedene Ports: 


    if flags dependency:
        interleave with dependency breaking instruction bi 1:1 and 9:1
        if TP_combined > TP_bi:
            TP = TP_combined - TP_mov (same ports)
        else (TP_combined == TP_bi)
            TP <= TP_combined (no final answer since either equal to TP_bi or limited by TP_bi)
        

    if instruction only one register (add eax, imm)
        interleave with mov eax, imm with TP_mov
        if TP_combined > TP_mov
            if same ports
                TP = TP_combined - TP_mov
            else different ports (how to detect???)
                TP = TP_combined
        else 
            TP = 

    alternative
        measure TP_add 
        measure TP_add with add_eax every 1/TP_add instructions
        if results are same -> TP is same
        for uops case: TP_add = 0.25 TP_add_eax = 0.33
            TP_combined = 3/4*0.25 + 1/4*0.33 = 0.27
            but this is not the case


profiling:
perf record -g ./my_program
perf script | ./FlameGraph/stackcollapse-perf.pl > out.folded
./FlameGraph/flamegraph.pl out.folded > flamegraph.svg

cmake .. -DLIBELF_INCLUDE_DIRS=/home/woody/ihpc/ihpc149h/USER-SPACK/opt/linux-ubuntu24.04-x86_64_v4/gcc-13.3.0/libelf-0.8.13-uisotbgdwwepizf5ukbn5l7mopfyxkh4/include \
-DLIBELF_LIBRARIES=/home/woody/ihpc/ihpc149h/USER-SPACK/opt/linux-ubuntu24.04-x86_64_v4/gcc-13.3.0/libelf-0.8.13-uisotbgdwwepizf5ukbn5l7mopfyxkh4/lib/libelf.so \
-DLIBDW_INCLUDE_DIR=/home/woody/ihpc/ihpc149h/USER-SPACK/opt/linux-ubuntu24.04-x86_64_v4/gcc-13.3.0/libelf-0.8.13-uisotbgdwwepizf5ukbn5l7mopfyxkh4/includ \
-DLIBDW_LIBRARIES=/home/woody/ihpc/ihpc149h/USER-SPACK/opt/linux-ubuntu24.04-x86_64_v4/gcc-13.3.0/libelf-0.8.13-uisotbgdwwepizf5ukbn5l7mopfyxkh4/lib/libdw.so
/home/hpc/ihpc/ihpc149h/bachelor/llvm-project/build/own_tools/llvm-bench/hotspot/build//extra-cmake-modules/build/install/usr/local/share/ECM/cmake/
cmake .. -DCMAKE_PREFIX_PATH=/home/hpc/ihpc/ihpc149h/bachelor/llvm-project/build/own_tools/llvm-bench/hotspot/build//extra-cmake-modules/build/install/usr/local/share/ECM/cmake/


cmake .. -DLIBELF_LIBRARIES=apps/SPACK/opt/linux-ubuntu24.04-x86_64_v4/gcc-13.3.0/libelf-0.8.13-uisotbgdwwepizf5ukbn5l7mopfyxkh4/lib/libelf.so
-DLIBELF_INCLUDE_DIRS=apps/SPACK/0.18.1/opt/linux-ubuntu24.04-x86_64_v4/gcc-13.3.0/libelf-0.8.13-uisotbgdwwepizf5ukbn5l7mopfyxkh4/include 

    code:
    add	eax, 42
	add	r13d, 42
	add	r14d, 42
	add	r15d, 42
    -> TP 0.25


    #TP 0.254 unrolled
	adc	ax, 42
	adc	cx, 42
	adc	dx, 42
	adc	si, 42
	adc	bx, 42
	adc	r9w, 42
	adc	r10w, 42
	adc	r11w, 42
	adc	r14w, 42
	adc	r15w, 42
	adc	r12w, 42
	adc	r13w, 42
    clc

    #TP 0.336 unrolled
	adc	r14w, 1
    xor eax, eax
	adc	cx, 1
    xor eax, eax
	adc	dx, 1
    xor eax, eax
	adc	si, 1
    xor eax, eax
	adc	bx, 1
    xor eax, eax
	adc	r9w, 1
    xor eax, eax
	adc	r10w, 1
    xor eax, eax
	adc	r11w, 1
    xor eax, eax

    #TP 0.253 unrolled
    adc cx, 1
    add	r13w, 1
	adc	bx, 1
    add	r14w, 1
	adc	r9w, 1
    add	r15w, 1
	adc	r10w, 1
    add cx, 1
	adc	r11w, 1
    add	bx, 1
    adc	r12w, 1
    add	r9w, 1
    adc	r13w, 1
    add	r10w, 1
    adc	r14w, 1
    add	r11w, 1
    adc	r15w, 1
    add	r12w, 1

    #TP 0.247 unrolled
    adox	ecx, ebx
	adox	edx, ebx
	adox	r9d, ebx
	adox	r10d, ebx
	adox	r11d, ebx
	adox	r12d, ebx
	adox	r13d, ebx
	adox	r14d, ebx
    xor eax, eax

    #TP 0.258 unrolled
    adox	ecx, ebx
    add	r12d, 1
	adox	edx, ebx
    add	r13d, 1
	adox	r9d, ebx
    add	r14d, 1
	adox	r10d, ebx
    add ecx, 1
	adox	r11d, ebx
    add	edx, 1
	adox	r12d, ebx
    add	r9d, 1
	adox	r13d, ebx
    add	r10d, 1
	adox	r14d, ebx
    add	r11d, 1

    
    #TP 0.336 unrolled
    adox	ecx, ebx
    xor eax, eax
	adox	edx, ebx
    xor eax, eax
	adox	r9d, ebx
    xor eax, eax
	adox	r10d, ebx
    xor eax, eax
	adox	r11d, ebx
    xor eax, eax
	adox	r12d, ebx
    xor eax, eax
	adox	r13d, ebx
    xor eax, eax
	adox	r14d, ebx
    xor eax, eax




#TODO
write meta script to setup llvm, insert and compile llvm-bench
look at shallow cloing llvm for this
compile llvm with Debug for development

important files:
RegAllocBase.cpp ?
X86RegisterInfo.td
X86TargetMachine.h

MCContext.h
MCSubtargetInfo.h
MCInst.h
MCInstDesc.h
MCRegister.h
MCRegisterInfo.h
TargetMachine.h
TargetSubtargetInfo.h
TargetRegistry.h
MachineRegisterInfo.h
MachineFunction.h
MachineOperand.h
MachineInstr.h


APX extension adds r16-r31
Registers are just in a certain order, so as more extensions are supported the index of the last supported register increases
see TRI->getNumSupportedRegs(*MF)

What if instructions interfere with instructions used by loop (cmp, jl, inc) (cmp and jl can be fused)
    run twice with ninst and 2*ninst for runimes a and b
    use formula x = ninst * (b - 2 * a) / (a - b)
    to get x interfering instructions and correct TP calculation 


SSE names
    fma, order of operands, packed, double 
    VFMADD132PD xmm1 xmm2 xmm3
        xmm1 = xmm1*xmm3 + xmm2
    VFMADD213PD xmm1 xmm2 xmm3
        xmm1 = xmm2*xmm1 + xmm3
    VFMADD231PD xmm1 xmm2 xmm3
        xmm1 = xmm2*xmm3 + xmm1

    in llvm:
    VFMADD132PDYm
    VFMADD132PD VR256 VR256 f256mem

    VFMADD132PDYr
    VFMADD132PD VR256 VR256 VR256

    VFMADD132PDm
    VFMADD132PD VR128 VR128 f128mem

    LLVM: 
    fma, order, packed, double, 256Bit(Y), 3rd operand register
    VFMADD132PDYr


    VFMADD132PDZ128m:
    fma, order, packed, 512Bit, ?, memory
    VR128X

    General (VFMADD132PDZ256mbkz)
    VFMADD {132|213|231}   {P|S}          {D|S}             { |Y|Z}       {128|256| }   {m|r}             {b| }       {k|kz| }
            operand order   packed|scalar  douvble|single       |AVX512    xmm|ymm|zmm   mem|reg (3rd op)  broadcast   destination_mask|zero_where_mask_0

    128|256 only available when Z (avx512)
    memory variant ignored in osaca?
    broadcast: uses a 64bit memory operand and boradcasts the value to the avx register before the fmadd


AArch64 names
    ADDSWrs 
    ADDS {W,X} r {x|i|s}
    add {32bit,64bit} register? {extended, immediate shifted}


clangd path is in workspace
clangd include paths in .clangd


	adox	eax, ecx
    test r12, r12
	adox	edx, esi
    test r12, r12
	adox	ebx, r9d
    test r12, r12
	adox	r10d, r11d
    test r12, r12
	adox	r14d, r15d
    test r12, r12
	adox	eax, ecx
    test r12, r12
	adox	edx, esi
    test r12, r12
	adox	ebx, r9d
    test r12, r12
	adox	r10d, r11d
    test r12, r12
	adox	r14d, r15d
    test r12, r12

TODO change to this
    std::pair<ErrorCode, AssemblyFile> genTPBenchmark(unsigned Opcode, unsigned *TargetInstrCount,
                                                  unsigned UnrollCount,
                                                  std::set<MCRegister> UsedRegisters,
                                                  std::map<unsigned, MCRegister> HelperConstraints,
                                                  int HelperOpcode) {
    // TODO change to list of opcodes
    dbg(__func__, "getting template");
    auto benchTemplate = getTemplate(env.MSTI->getTargetTriple().getArch());
    // extract list of registers used by the template
    // TODO optimize
    dbg(__func__, "getting usedRegs");
    for (unsigned i = 0; i < env.MRI->getNumRegs(); i++) {
        MCRegister reg = MCRegister::from(i);
        if (benchTemplate.usedRegisters.find(env.TRI->getRegAsmName(reg).lower().data()) !=
            benchTemplate.usedRegisters.end())
            UsedRegisters.insert(reg);
    }

    dbg(__func__, "call gen inner loop");

    // this is the hepler instruction if needed.
    std::list<MCInst> instructions;
    ErrorCode EC;
    auto currentUsedRegisters = UsedRegisters;
    if (HelperOpcode > -1) {
        unsigned helperOpcode = HelperOpcode;
        std::tie(EC, instructions) =
            genTPInnerLoop4({Opcode, helperOpcode}, {{}, HelperConstraints}, *TargetInstrCount,
                            currentUsedRegisters);
        if (EC != SUCCESS) return {EC, AssemblyFile()};
        // update TargetInstructionCount to actual number of instructions generated, dont include
        // helper instructions
        *TargetInstrCount = UnrollCount * instructions.size() / 2;
    } else {
        // ho helper
        std::tie(EC, instructions) =
            genTPInnerLoop4({Opcode}, {{}}, *TargetInstrCount, currentUsedRegisters);
        if (EC != SUCCESS) return {EC, AssemblyFile()};
        // update TargetInstructionCount to actual number of instructions generated
        *TargetInstrCount = UnrollCount * instructions.size();
    }
    auto benchUsedRegistes = env.regDifference(currentUsedRegisters, UsedRegisters);

    dbg(__func__, "inner loop generated");

    // save registers used (genTPInnerLoop updates usedRegisters)
    std::string saveRegs;
    std::string restoreRegs;
    std::string initCode;
    llvm::raw_string_ostream ico(initCode);
    for (MCRegister reg : benchUsedRegistes) {
        if (env.TRI->isCalleeSavedPhysReg(reg, *env.MF)) {
            // generate code to save and restore register
            // this currently also saves registers already saved in the template
            // which is redundant but not harmful
            auto [EC1, save] = genSaveRegister(reg);
            if (EC1 != SUCCESS) return {EC1, AssemblyFile()};
            saveRegs.append(save);
            auto [EC2, restore] = genRestoreRegister(reg);
            if (EC2 != SUCCESS) return {EC2, AssemblyFile()};
            restoreRegs.insert(0, restore);
        }
        ico << genRegInit(reg, "0x4", benchTemplate);
    }

    dbg(__func__, "starting to build benchmark code");

    std::string singleLoopCode;
    llvm::raw_string_ostream slo(singleLoopCode);
    for (auto inst : instructions) {
        env.MIP->printInst(&inst, 0, "", *env.MSTI, slo);
        slo << "\n";
    }
    std::string loopCode;
    for (unsigned i = 0; i < UnrollCount; i++)
        loopCode.append(singleLoopCode);

    AssemblyFile assemblyFile(env.Arch);
    assemblyFile.addInitFunction("init", saveRegs + initCode + singleLoopCode + restoreRegs + "\n");
    assemblyFile.addBenchFunction("tp", saveRegs, loopCode, restoreRegs, "init");
    assemblyFile.addBenchFunction("tpUnroll2", saveRegs, loopCode + loopCode, restoreRegs, "init");
    assemblyFile.addBenchFunction("tpUnroll4", saveRegs, loopCode + loopCode + loopCode + loopCode,
                                  restoreRegs, "init");
    return {SUCCESS, assemblyFile};
}