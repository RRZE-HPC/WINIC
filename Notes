
TODO
    installed valgrind but how to load
    /dev/shm/temp.s:114:2: error: instruction requires: Not 64-bit mode mov cr0, eax investigate
    no helper EFLAGS (28) -> Class(GR64) -maybe fixed, check
    BTC16ri8 has r->r 1 and r->flags 2 but i get opposite?
    there may be implicit dependencys which hide the latency we want to measure. -> add a check for this
    loop_tpUnroll2 asm label imnprove naming convention
    something is causing free(): invalid (genoa, TP, around opcode 4692)
    latency performance is not dominated by loop, check maybe impact of helpers 
    some instructions e.g. adc (ADC16ri8) on zen4 get a TP penalty when unrolling the loop without breaking the dependency on the flags. try to avoid
    add frequency check
    check latency results with uops
    test lukewarm
        test Latency
        test sve
    test riscv
        add templates for riscv plan release packaging configure llvm installation to include clang but be as fast as possible
    properly organize and create headers
    instructions with weird TP values
        ADD_FST0r 
        XOR8rr_NOREX
        ADC16ri8 - adcs are broken bc of flags dependency
        CLC
        CMC
        COM_FIPr
        DIV16r
        IMUL16r
        LAHF
        MUL32r
        MUL8r - broken because always on same register
    instructions with weird LAT values
        VRSQRTSSr -0.5 in bench but correct 4.0 when single measurement?
        VUNPCKLPDZrr - 1.114 but should be 1.0 -> probably transition penalty? not solved via init function
        HADDPDrr - 4.45 but should be 4.0 -> same reason as VUNPCKLPDZrr?
        CVTSI2SDrr
        CDQ
        CMP16ri
        SUB32rr broken in Lat4.log check if fixed now 


    done:
    instructions with weird values
        -COM_Fpr32 - was an undetected pseudo instruction
    -restructure project
    -write global toString function
    -put normal and unrolled benchmarks in same assemby file
    -change latency bench to also use instructions which access superregisters or subregisters as helper -dont do that, could enable optimizations
    -/usr/bin/ld: warning: /tmp/temp-c3f742.o: missing .note.GNU-stack section implies executable stack
    -init registers (e.g. avoid avx-sse transition penalty)
    -latency genInst not optimal, VANDNPSZ128rr uses same reg for both reads allowing for optimization to happen
    -dont spawn subprocess for every instruction
    -rename ERRORS
    -Helper instructions have to be handled outside of the subprocess otherwise they dont see each other
    -dont use subprocess
    -remove rounding in loop overhead calculation
    -reuse readonly regs for TP bench, in some cases there are too few instructions (MMX_PMULLWrr)
    -move to clang for assembling to avoid gcc dependency
    -    ->check if equal number of successful measurements
    -    ->check if syntaxVariants are still correct
    -test if variant with clang assembler works on x86
    -MCInstrPrinter segfaults when instruction is wrong (or is Prefix)
    -check filtering memory instructions
    -implement loop instruction interference detection
    -compile and run benchmarks from inside program
    -save callee saved registers

State
    Conditional moves measure garbage CMOVNE_F
    ND and EVEX encoded variants cause ERROR_ASSEMBLY (this is ok, normal variants get measured)
    where to verify aarch data -osaca
    -how to set/read clock frequency on arm
        warmup: 2.2GHz
        grace admin
    likwid broken on arm likwid/grace

Questions:
    always same immediate correct?
    TP only to determine number of execution units?


helpful
    TRI->getRegAsmName(MCRegister)
    llvm::X86::getFeaturesForCPU(StringRef CPU, SmallVectorImpl<StringRef> &Features)
    desc.hasImplicitUseOfPhysReg(MCRegister::from(X86::EFLAGS))
    MCII->getName(opcode).data()

use 2.4Ghz on genoa1 and 2.3Ghz on genoa2

cd bachelor/llvm-project/build/own_tools/llvm-bench
salloc --nodes=1 -w icx36 --time=02:00:00 -C hwperf
srun --nodes=1 -w genoa1 --time=04:00:00 --cpu-freq=2400000-2400000:performance ./LLVMBench LAT -f 2.4 > genoaLat.log
srun --nodes=1 -w genoa1 --time=04:00:00 --cpu-freq=2400000-2400000:performance ./LLVMBench TP -f 2.4 > genoa.log
srun --cpu-freq=2400000-2400000:performance ./LLVMBench LAT -f 2.4 > genoaLAT.log
srun --cpu-freq=2400000-2400000:performance ./LLVMBench TP -f 2.4 --minOpcode=4699 --maxOpcode=4700 > genoa.log
srun --cpu-freq=2400000-2400000:performance ./LLVMBench TP -f 2.4 -o 4693
srun --cpu-freq=2400000-2400000:performance ./LLVMBench LAT -f 2.4 -n 1000 > genoaLatDebug.log
srun --cpu-freq=2400000-2400000:performance cat /proc/cpuinfo | grep MHz
srun --cpu-freq=2400000-2400000:performance ./LLVMBench LAT -f 2.4 -i ADC16ri8
srun --cpu-freq=2400000-2400000:performance ./LLVMBench TP -f 2.4 -i ADC16ri8
srun --cpu-freq=2400000-2400000:performance ./quick 2.4
./LLVMBench -f 2.2 > warmup.log

#compiled with -fsanitize=address -fno-omit-frame-pointer, works only sometimes, run ~5 times
./LLVMBench TP -f 2.4 -o 2567 &> sanitize1.log

srun --cpu-freq=2400000-2400000:performance ./LLVMBench -f 2.4 -i MMX_PMULLWrr 

benchmark
    perf record -g ./LLVMBench LAT -f 2.4 -n 1000
    perf record -g --call-graph dwarf ./LLVMBench LAT -f 2.4 --minOpcode=1000
    perf script | ./FlameGraph/stackcollapse-perf.pl > out.folded
    ./FlameGraph/flamegraph.pl out.folded > flamegraph_debugClang.svg

Testfront setup
    salloc --nodes=1 -w icx36 --time=02:00:00
    salloc --nodes=1 -w genoa1 --time=02:00:00

    module load cmake gcc python
    mkdir -p llvm-project/build && cd llvm-project/build
    cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_LLVM_DYLIB=ON -DLLVM_LINK_LLVM_DYLIB=ON ../llvm
    cmake --build . -- -j 32
    mkdir own_tools && cd own_tools
    git clone https://github.com/TobiasRTR/llvm-bench.git

    #build with clangd or all
    cmake -DCMAKE_BUILD_TYPE=Release ../llvm -DLLVM_BUILD_LLVM_DYLIB=ON -DLLVM_LINK_LLVM_DYLIB=ON -DLLVM_ENABLE_PROJECTS="clang;clang-tools-extra"
    cmake --build . --target clangd/all -- -j 64


    build_x86_2 (this will be 150GB)
    cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo ../llvm -DLLVM_BUILD_LLVM_DYLIB=ON -DLLVM_LINK_LLVM_DYLIB=ON -DLLVM_ENABLE_PROJECTS="clang;clang-tools-extra" -DLLVM_INSTALL_TOOLCHAIN_ONLY=ON
    cmake --build . --target install -- -j 64

    # iwyu
    git clone https://github.com/llvm/llvm-project.git
    git clone https://github.com/include-what-you-use/include-what-you-use.git
    cd llvm-project
    git checkout release/20.x
    cd ../include-what-you-use
    git checkout release/clang_20
    cd ..
    mkdir build && cd build
    cmake -DCMAKE_BUILD_TYPE=Release ../llvm -DLLVM_ENABLE_PROJECTS=clang -DLLVM_EXTERNAL_PROJECTS=iwyu -DLLVM_EXTERNAL_IWYU_SOURCE_DIR=../../include-what-you-use 
    likwid-pin -c 0-191 cmake --build . -- -j 192
    alias iwyu="/home/woody/ihpc/ihpc149h/bachelor/llvm-project/build/bin/include-what-you-use"


    # create compile_commands.json
    ~/bachelor/llvm-project/build_x86/bin/intercept-build make
    

total runtime: 34.612634 (s) lat n= 1000


x86:
CLD
BSWAP64r r64 
ADD64rr r64 r64
ADD64ri32 r64 i32
ADC16i16 i16 always works on ax, how to measure TP
VFMADD132PDYr ymm ymm ymm


AArch64:
ABSWr
FMADDDrrr

Constraints for immediates x86 TODO test:
    MMX_PALIGNRrri imm < 12 or else lat 2 instead of 0.5 bc result 0


Später: Portbelegung

Sei A Instruktion mit Lat_A, TPr_A und B Instruktion mit Lat_B, TPr_B
A und B nutzen nur einen Port während ihrer Ausführung TODO was wenn nicht
Sei TPr_B < Lat_A
Sei T die Anzahl von Taktzyklen, die eine Latenzkette von A, beliebiger aber fester Länge braucht
Sei TI_n die Anzahl von Taktzyklen, die die Kette braucht wenn n unabhängige Bs nach jedem A eingefügt werden
    Wenn A und B unterschiedliche Ports nutzen bleibt T bei n *  <= Lat_A / TPr_B gleich
    Wenn A und B die selben Ports nutzen steigt T bereits vorher

zusätzlich: falls überlappung nicht erkannt weil nutzung des uberlappenden ports sehr gering,
finde trotzdem indirekt durch instruktion die den Port hauptsächlich verwendet


MUL8r -> latenz wird gemessen weil immer auf al
    Lösug: interleave mit mov rax, 42
    -> TP = 1.0
    Frage: muss man noch die 0.25 vom mov abziehen? -> 0.75
    oder nicht -> 1.0
        Lösung: interleave mit MOV bricht dependency
        miss MUL:MOV 1:1: und 1:2
        wenn TP_MUL gleich bleibt muss mov auf anderen Ports laufen
        wenn TP_MUL sinkt sind es die gleichen Ports
        Bedingung: TP_MOV muss kleiner gleich 1/2 TP_MUL sein

Sei TP_MOV <= TP_MUL /2
Sei T_11 die Zeit von MUL und MOV 1:1 interleaved
Sei T_12 der Zeit von MUL und MOV 1:2 interleaved
    Wenn MUL und MOV gleiche Ports nutzen:
        Die zusätzlichen MOVs müssen die Ausführungszeit verlängern
        -> T_12 > T_11
    Wenn MUL und MOV Verschiedene Ports nutzen:
        TP_MOV <= TP_MUL / 2 -> T_MOV <= T_MUL / 2 
        2 * T_MOV <= 2 * (T_MUL / 2 )
        -> 2 * T_MOV <= T_MUL
        MUL und MOV auf verschiedenen Ports
        -> MOVs verschwinden hinter MULs und erhöhen die Laufzeit nicht



Paper
    Latency on adc	ax, 42 not possible, use auto detected interleave instruction 
    which reads adc and writes flags, subtract TP of interleave instruction (e.g. cmp)

    ADC kein TP
    ADD TP=0.25 bricht adc dependency
    wenn beide auf verschiedenen ports laufen gibt es eine ratio bei der beide tps kleiner gleich dem minimalen einzel TP sind
    wenn 1:1 run: keine dependencys
        wenn gleiche Ports: TP_comb = TPadc + TPadd
        wenn verschiedene Ports: 


    if flags dependency:
        interleave with dependency breaking instruction bi 1:1 and 9:1
        if TP_combined > TP_bi:
            TP = TP_combined - TP_mov (same ports)
        else (TP_combined == TP_bi)
            TP <= TP_combined (no final answer since either equal to TP_bi or limited by TP_bi)
        

    if instruction only one register (add eax, imm)
        interleave with mov eax, imm with TP_mov
        if TP_combined > TP_mov
            if same ports
                TP = TP_combined - TP_mov
            else different ports (how to detect???)
                TP = TP_combined
        else 
            TP = 

    alternative
        measure TP_add 
        measure TP_add with add_eax every 1/TP_add instructions
        if results are same -> TP is same
        for uops case: TP_add = 0.25 TP_add_eax = 0.33
            TP_combined = 3/4*0.25 + 1/4*0.33 = 0.27
            but this is not the case


profiling:
perf record -g ./my_program
perf script | ./FlameGraph/stackcollapse-perf.pl > out.folded
./FlameGraph/flamegraph.pl out.folded > flamegraph.svg

cmake .. -DLIBELF_INCLUDE_DIRS=/home/woody/ihpc/ihpc149h/USER-SPACK/opt/linux-ubuntu24.04-x86_64_v4/gcc-13.3.0/libelf-0.8.13-uisotbgdwwepizf5ukbn5l7mopfyxkh4/include \
-DLIBELF_LIBRARIES=/home/woody/ihpc/ihpc149h/USER-SPACK/opt/linux-ubuntu24.04-x86_64_v4/gcc-13.3.0/libelf-0.8.13-uisotbgdwwepizf5ukbn5l7mopfyxkh4/lib/libelf.so \
-DLIBDW_INCLUDE_DIR=/home/woody/ihpc/ihpc149h/USER-SPACK/opt/linux-ubuntu24.04-x86_64_v4/gcc-13.3.0/libelf-0.8.13-uisotbgdwwepizf5ukbn5l7mopfyxkh4/includ \
-DLIBDW_LIBRARIES=/home/woody/ihpc/ihpc149h/USER-SPACK/opt/linux-ubuntu24.04-x86_64_v4/gcc-13.3.0/libelf-0.8.13-uisotbgdwwepizf5ukbn5l7mopfyxkh4/lib/libdw.so
/home/hpc/ihpc/ihpc149h/bachelor/llvm-project/build/own_tools/llvm-bench/hotspot/build//extra-cmake-modules/build/install/usr/local/share/ECM/cmake/
cmake .. -DCMAKE_PREFIX_PATH=/home/hpc/ihpc/ihpc149h/bachelor/llvm-project/build/own_tools/llvm-bench/hotspot/build//extra-cmake-modules/build/install/usr/local/share/ECM/cmake/


cmake .. -DLIBELF_LIBRARIES=apps/SPACK/opt/linux-ubuntu24.04-x86_64_v4/gcc-13.3.0/libelf-0.8.13-uisotbgdwwepizf5ukbn5l7mopfyxkh4/lib/libelf.so
-DLIBELF_INCLUDE_DIRS=apps/SPACK/0.18.1/opt/linux-ubuntu24.04-x86_64_v4/gcc-13.3.0/libelf-0.8.13-uisotbgdwwepizf5ukbn5l7mopfyxkh4/include 

    code:
    add	eax, 42
	add	r13d, 42
	add	r14d, 42
	add	r15d, 42
    -> TP 0.25


    #TP 0.254 unrolled
	adc	ax, 42
	adc	cx, 42
	adc	dx, 42
	adc	si, 42
	adc	bx, 42
	adc	r9w, 42
	adc	r10w, 42
	adc	r11w, 42
	adc	r14w, 42
	adc	r15w, 42
	adc	r12w, 42
	adc	r13w, 42
    clc

    #TP 0.336 unrolled
	adc	r14w, 1
    xor eax, eax
	adc	cx, 1
    xor eax, eax
	adc	dx, 1
    xor eax, eax
	adc	si, 1
    xor eax, eax
	adc	bx, 1
    xor eax, eax
	adc	r9w, 1
    xor eax, eax
	adc	r10w, 1
    xor eax, eax
	adc	r11w, 1
    xor eax, eax

    #TP 0.253 unrolled
    adc cx, 1
    add	r13w, 1
	adc	bx, 1
    add	r14w, 1
	adc	r9w, 1
    add	r15w, 1
	adc	r10w, 1
    add cx, 1
	adc	r11w, 1
    add	bx, 1
    adc	r12w, 1
    add	r9w, 1
    adc	r13w, 1
    add	r10w, 1
    adc	r14w, 1
    add	r11w, 1
    adc	r15w, 1
    add	r12w, 1

    #TP 0.247 unrolled
    adox	ecx, ebx
	adox	edx, ebx
	adox	r9d, ebx
	adox	r10d, ebx
	adox	r11d, ebx
	adox	r12d, ebx
	adox	r13d, ebx
	adox	r14d, ebx
    xor eax, eax

    #TP 0.258 unrolled
    adox	ecx, ebx
    add	r12d, 1
	adox	edx, ebx
    add	r13d, 1
	adox	r9d, ebx
    add	r14d, 1
	adox	r10d, ebx
    add ecx, 1
	adox	r11d, ebx
    add	edx, 1
	adox	r12d, ebx
    add	r9d, 1
	adox	r13d, ebx
    add	r10d, 1
	adox	r14d, ebx
    add	r11d, 1

    
    #TP 0.336 unrolled
    adox	ecx, ebx
    xor eax, eax
	adox	edx, ebx
    xor eax, eax
	adox	r9d, ebx
    xor eax, eax
	adox	r10d, ebx
    xor eax, eax
	adox	r11d, ebx
    xor eax, eax
	adox	r12d, ebx
    xor eax, eax
	adox	r13d, ebx
    xor eax, eax
	adox	r14d, ebx
    xor eax, eax




#TODO
write meta script to setup llvm, insert and compile llvm-bench
look at shallow cloing llvm for this
compile llvm with Debug for development

important files:
RegAllocBase.cpp ?
X86RegisterInfo.td
X86TargetMachine.h

MCContext.h
MCSubtargetInfo.h
MCInst.h
MCInstDesc.h
MCRegister.h
MCRegisterInfo.h
TargetMachine.h
TargetSubtargetInfo.h
TargetRegistry.h
MachineRegisterInfo.h
MachineFunction.h
MachineOperand.h
MachineInstr.h


APX extension adds r16-r31
Registers are just in a certain order, so as more extensions are supported the index of the last supported register increases
see TRI->getNumSupportedRegs(*MF)

What if instructions interfere with instructions used by loop (cmp, jl, inc) (cmp and jl can be fused)
    run twice with ninst and 2*ninst for runimes a and b
    use formula x = ninst * (b - 2 * a) / (a - b)
    to get x interfering instructions and correct TP calculation 


SSE names
    fma, order of operands, packed, double 
    VFMADD132PD xmm1 xmm2 xmm3
        xmm1 = xmm1*xmm3 + xmm2
    VFMADD213PD xmm1 xmm2 xmm3
        xmm1 = xmm2*xmm1 + xmm3
    VFMADD231PD xmm1 xmm2 xmm3
        xmm1 = xmm2*xmm3 + xmm1

    in llvm:
    VFMADD132PDYm
    VFMADD132PD VR256 VR256 f256mem

    VFMADD132PDYr
    VFMADD132PD VR256 VR256 VR256

    VFMADD132PDm
    VFMADD132PD VR128 VR128 f128mem

    LLVM: 
    fma, order, packed, double, 256Bit(Y), 3rd operand register
    VFMADD132PDYr


    VFMADD132PDZ128m:
    fma, order, packed, 512Bit, ?, memory
    VR128X

    General (VFMADD132PDZ256mbkz)
    VFMADD {132|213|231}   {P|S}          {D|S}             { |Y|Z}       {128|256| }   {m|r}             {b| }       {k|kz| }
            operand order   packed|scalar  douvble|single       |AVX512    xmm|ymm|zmm   mem|reg (3rd op)  broadcast   destination_mask|zero_where_mask_0

    128|256 only available when Z (avx512)
    memory variant ignored in osaca?
    broadcast: uses a 64bit memory operand and boradcasts the value to the avx register before the fmadd


AArch64 names
    ADDSWrs 
    ADDS {W,X} r {x|i|s}
    add {32bit,64bit} register? {extended, immediate shifted}


clangd path is in workspace
clangd include paths in .clangd


	adox	eax, ecx
    test r12, r12
	adox	edx, esi
    test r12, r12
	adox	ebx, r9d
    test r12, r12
	adox	r10d, r11d
    test r12, r12
	adox	r14d, r15d
    test r12, r12
	adox	eax, ecx
    test r12, r12
	adox	edx, esi
    test r12, r12
	adox	ebx, r9d
    test r12, r12
	adox	r10d, r11d
    test r12, r12
	adox	r14d, r15d
    test r12, r12